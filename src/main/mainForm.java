package main;

import java.awt.event.ActionEvent;
import java.awt.Color;
import java.awt.Graphics;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.stream.Collectors;
import javax.swing.JPanel;
import javax.swing.Timer;

public class mainForm extends javax.swing.JFrame {
// Variables declaration - do not modify//GEN-BEGIN:variables
private javax.swing.JPanel jPanelResult;
private javax.swing.JPanel jPanelTerrain;
// End of variables declaration//GEN-END:variables

private ArrayList<Adversary> adversaries = new ArrayList<>();
private ArrayList<javax.swing.JLabel> values = new ArrayList<>();
private javax.swing.Timer timerUpdateSimulation;
private static int timer_counter = 0;
private int next_bacteria = 0;

public mainForm() throws Exception {
	initComponents();
	Food food = new Food(1024, 640, Food.Distribution.SQUARE);
	Bacteria.setFood(food);
	try {
		inizializzaBatteri();
	} catch (Exception e) {
		System.out.println("panic during inizialization");
		System.exit(1);
	}
	this.jPanelTerrain.add(new JPanel() {
		@Override
		public void paintComponent(Graphics g) {
			g.setColor(jPanelTerrain.getBackground());
			g.fillRect(0, 0, this.getWidth(), this.getHeight());
			for (var a : adversaries) {
				g.setColor(a.color);
				for (int i=0; i<a.entities.size(); i++) {
					Bacteria b = (Bacteria) a.entities.get(i);
					g.fillRect(b.x, b.y, 3, 3);
				}
			}
			g.setColor(Color.GREEN);
			int local_food_height = Food.getHeight();
			int local_food_width = Food.getWidth();
			for (int i=0; i<local_food_height; i++)
				for (int j=0; j<local_food_width; j++)
					if (Food.isFood(j, i)) g.fillRect(j, i, 2, 2);
		}
	});

	javax.swing.JButton btnStart = new javax.swing.JButton("Start");
	btnStart.addActionListener((ActionEvent e) -> {
		timerUpdateSimulation.start();
	});
	this.jPanelResult.add(btnStart);
	javax.swing.JButton btnStop = new javax.swing.JButton("Stop");
	btnStop.addActionListener((ActionEvent e) -> {
		timerUpdateSimulation.stop();
	});
	this.jPanelResult.add(btnStop);
	pack();
	this.setSize(
		Food.getWidth() + 300, // LARGHEZZA_PANNELLO_LATERALE
		Food.getHeight() + 50  // ALTEZZA_BORDO
	);

	timerUpdateSimulation = new Timer(50, (ActionEvent e) -> {
		simulation_cycle(next_bacteria);
		next_bacteria++;
		if (next_bacteria >= adversaries.size()) next_bacteria = 0;
		jPanelTerrain.repaint();
		if (timer_counter++ % 20 != 0) return;
		food.toggle();
		// TODO FPS counter
		for (int i = 0; i < adversaries.size(); i++) {
			if (adversaries.get(i).entities.isEmpty()) {
				System.out.println("(" + adversaries.get(i).name + " is dead)");
				values.get(i).setText(adversaries.get(i).name + " 0");
				values.remove(i);
				adversaries.remove(i);
				i--;
			} else {
				values.get(i).setText(
					adversaries.get(i).name + " " + 
					adversaries.get(i).entities.size() + " " +
					adversaries.get(i).medium_time
				);
			}
		}
	});
}

private void inizializzaBatteri() throws Exception {
	Path path = Paths.get("./build/classes/children/");
	var names = Files.walk(path)
		.map(Path::getFileName)
		.map(Path::toString)
		.filter(n -> n.endsWith(".class"))
		.map(n -> n.replace(".class", ""))
		.collect(Collectors.toCollection(ArrayList::new));
	if (names.isEmpty()) {
		System.out.println("no classes found in " + path);
	} else {
		System.out.println("Classes found:");
		for (String name : names) System.out.println("- " + name);
	}
	for (int i = 0; i < names.size(); i++) {
		String name = names.get(i);
		try {
			Adversary<?> c = new Adversary<>(
				name,
				Class.forName("children." + name)
			);
			adversaries.add(c);
			values.add(new javax.swing.JLabel(
				name + " " + adversaries.get(i).entities.size()
			));
			values.get(i).setForeground(adversaries.get(i).color);
			jPanelResult.add(values.get(i));
		} catch (Exception e) {
			System.out.println(name + " is not a valid bacteria");
			names.remove(i--);
		}
	}
}

/**
 * This method is called from within the constructor to initialize the form.
 * WARNING: Do NOT modify this code. The content of this method is always
 * regenerated by the Form Editor.
 */
// <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
private void initComponents() {
	jPanelResult = new javax.swing.JPanel();
	jPanelTerrain = new javax.swing.JPanel();
	setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
	setTitle("Bacteria");
	setMinimumSize(new java.awt.Dimension(1324, 700));
	setResizable(false);
	jPanelResult.setBorder(javax.swing.BorderFactory.createLineBorder(
		new java.awt.Color(0, 0, 0)
	));
	jPanelResult.setMinimumSize(new java.awt.Dimension(150, 100));
	jPanelResult.setPreferredSize(new java.awt.Dimension(300, 70));
	jPanelResult.setLayout(new javax.swing.BoxLayout(
		jPanelResult, javax.swing.BoxLayout.Y_AXIS
	));
	getContentPane().add(jPanelResult, java.awt.BorderLayout.LINE_END);
	jPanelTerrain.setBackground(new java.awt.Color(255, 255, 255));
	jPanelTerrain.setMinimumSize(new java.awt.Dimension(1324, 700));
	jPanelTerrain.setPreferredSize(new java.awt.Dimension(1024, 700));
	jPanelTerrain.setLayout(new java.awt.BorderLayout());
	getContentPane().add(jPanelTerrain, java.awt.BorderLayout.CENTER);
	pack();
}// </editor-fold>//GEN-END:initComponents

public static void main(String args[]) {
	try {
		new mainForm().setVisible(true);
	} catch (Exception e) {
		System.exit(1);
	}
}

private void simulation_cycle(int next_bacteria) {
	// shuffle adversaries for fairness
	// use a pointer over Collections.shuffle() to maintain maximum fairness

	int index = next_bacteria;
	while (true) {
		if (index >= adversaries.size()) index = 0;
		Adversary a = adversaries.get(index);
		ArrayList<Bacteria> babies = new ArrayList<>();
		var start = System.nanoTime();
		for (int i=0; i< a.entities.size(); i++) {
			Bacteria b = (Bacteria) a.entities.get(i);
			if (! b.run()) {
				a.entities.remove(i--);
				continue;
			}
			if (b.isReadyForCloning()) {
				int xp = b.x, yp = b.y;
				try {
					Bacteria clone = (Bacteria) b.clone();
					// impose the father's coordinates
					clone.x = xp; clone.y = yp;
					babies.add(clone);
				} catch (Exception e) {
					System.out.println(a.name + " panics during cloning");
				}
				// prevent the father from moving during the
				// cloning phase without consuming health
				b.x = xp; b.y = yp;
			}
		}
		var end = System.nanoTime() - start;
		if (!a.entities.isEmpty()) {
			// reuse previous time to stabilize the output
			a.medium_time = (a.medium_time + (end / a.entities.size()))/2;
			a.entities.addAll(babies); // should improve cache locality
		}
		if (next_bacteria == 0 && index == adversaries.size()-1) break;
		else if (index == next_bacteria-1) break;
		index++;
	}
}

public static int getTimerCounter() {
	return mainForm.timer_counter;
}
}
